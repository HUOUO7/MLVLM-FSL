import pandas as pd
import json
import re
# Reassemble unreliable instructions from qwen's first round of output into new ones (candidate answers are filtered)

def extract_class_names(row):
    # notune top2-first qwen-sencond
    # tuned first-qwen  top2-second
    global filter
    global ans_num
    categories = row['categories'].split(', ')
    qwen_idx = row['qwen_idx']
    all_avg_index = list(map(int, row['all_avg_index'].split('-')))


    top2_classes = [categories[idx - 1] for idx in all_avg_index[:2]]
    top3_classes = [categories[idx - 1] for idx in all_avg_index[:3]]


    if qwen_idx == 0:
        selected_classes = top3_classes
    else:

        qwen_class = categories[qwen_idx - 1]
        if type_c == "NOTUNE":
            selected_classes = top2_classes + [qwen_class]
        else:
            selected_classes = [qwen_class] + top2_classes

    return ', '.join(selected_classes)


def filter_conversation(conversation, filter_classes):
    for conv in conversation:
        if conv['from'] == 'user':
            user_value = conv['value']
            pattern = r"Picture \d+: <img>(.*?)</img>\n What is this\? (.*?)\."
            matches = re.findall(pattern, user_value)

            filtered_parts = []
            class_to_parts = {}
            query_part = ""

            for img_path, bird_name in matches:
                if bird_name.lower() in filter_classes:
                    class_to_parts[bird_name.lower()] = f"<img>{img_path}</img>\n What is this? {bird_name}."

            # Rearrange the session sections in the order of filter_classes
            for idx, class_name in enumerate(filter_classes, start=1):
                if class_name in class_to_parts:
                    filtered_parts.append(f"Picture {idx}: {class_to_parts[class_name]}")

            query_pattern = r"Picture 6: <img>(.*?)</img>\n So what is this\?"
            query_match = re.search(query_pattern, user_value)

            if query_match:
                query_img_path = query_match.group(1)
                query_part = f"Query Picture 4: <img>{query_img_path}</img>\n So what is this?"

            answer_list = [class_to_parts[class_name].split('\n')[-1].split('? ')[1].split('.')[0] for class_name in
                           filter_classes]
            answer_list_part = f"Output is one of {answer_list}. Make sure your output is in the answer list, with no spelling mistakes."

            filtered_value = "\n".join(filtered_parts) + "\n" + query_part + "\n" + answer_list_part
            conv['value'] = filtered_value
    return conversation


# Step 1
# Given the csv_file_path that generated by 3-chose_no_match.py
# Given the json_file_path which is the original Qwen output json file
# Given the output_file_path which is the new json file that will be written
type_c ="pseudo"
datasetname = "CUB"
csv_file_path = f"path/to/{datasetname}/mismatched_rows_{type_c}.csv"
json_file_path = f"path/to/qwen/{datasetname}/{datasetname}_novel_5way1shot1query.json"
output_file_path = f"path/to/{datasetname}/0807{datasetname}_{type_c}_3WAY.json"

filter =  0
ans_num = 4
csv_df = pd.read_csv(csv_file_path)


with open(json_file_path, 'r') as json_file:
    json_data = json.load(json_file)

# Step 2 reorganize the json_data which will prompt Qwen again later
csv_ids = csv_df['id'].tolist()

filtered_json_data = []
for item in json_data:
    if item['id'] in csv_ids:
        csv_row = csv_df[csv_df['id'] == item['id']].iloc[0]
        filter_class = extract_class_names(csv_row).lower().split(', ')
        item['conversations'] = filter_conversation(item['conversations'], filter_class)

        filtered_json_data.append(item)

# Step 3 Write the filtered data to a new JSON file
with open(output_file_path, 'w') as output_file:
    json.dump(filtered_json_data, output_file, indent=4)
print(len(filtered_json_data))

print(f"succeed in {output_file_path}")
