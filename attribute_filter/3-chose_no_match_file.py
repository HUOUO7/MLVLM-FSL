import pandas as pd

# If the instructions whose qwen_idx is not in all_avg_index top2 , they are regarded as unreliable and incompatible, i.e. mismatched.

# Step 1
# Given file_dir that generated by 1_cal_aggregate_similarity.py
# Given output_file to save the mismatched rows
typec = "pseudo"
datasetname = "CUB"
file_dir = f"path/to/{datasetname}/0807_{datasetname}_output_v1_{typec}_all_index.csv"
output_file = f"path/to/{datasetname}/mismatched_rows_{typec}.csv"


df = pd.read_csv(file_dir)
filter = 0
ans_num = 2


# Step2 Filter out the rows where qwen_idx and all_avg_index top2 do not match
mismatched_rows = []
total = 0
correct = 0
top3_correct = 0

for index, row in df.iterrows():
    all_avg_index = list(map(int, row['all_avg_index'].split('-')))
    try:
        qwen_idx = int(row['qwen_idx'])
    except ValueError:
        qwen_idx = 0
    ground_truth = int(row['ground_idx'])

    if qwen_idx not in all_avg_index[:2]:
        mismatched_rows.append(row)
        total += 1
        if qwen_idx == ground_truth:
            correct += 1
        # Check if ground_truth is in the top-2 and qwen_idx
        top3_indices = all_avg_index[:2] + [qwen_idx]
        if ground_truth in top3_indices:
            top3_correct += 1


# Step 3 Write the mismatched rows data to a file
mismatched_df = pd.DataFrame(mismatched_rows)
mismatched_df.to_csv(output_file, index=False)

accuracy = correct / total if total > 0 else 0
top3_accuracy = top3_correct / total if total > 0 else 0

print(f"Filtered unmatched rows have been written to {output_file}")
print(f"The correct number of qwen_idx in ground_idx originally: {correct}, total: {total}, accuracy: {accuracy:.2%}")
print(
    f"The correct number of top2 + qwen_idx of all_avg_index in ground_idx: {top3_correct}, total: {total}, accuracy: {top3_accuracy:.2%}")
